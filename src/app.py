import streamlit as st
import pandas as pd
import requests
from os import getenv
from dotenv import load_dotenv
from io import StringIO
import plotly.express as px

# =========================
# Configuration g√©n√©rale
# =========================
load_dotenv()
GITHUB_TOKEN = getenv("GITHUB_TOKEN")
REPO = "cedric-mc/analyse-marche"
CSV_PATH = "annonces_propres.csv"
CSV_URL = f"https://raw.githubusercontent.com/{REPO}/main/{CSV_PATH}"

st.set_page_config(
    page_title="üè† Analyse Immo LDF",
    layout="wide",
    page_icon="üè°"
)

# =========================
# Fonctions utilitaires
# =========================
def apply_custom_css():
    """Injecte le style personnalis√© dans la page Streamlit."""
    st.markdown("""
    <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap');
    /* Styles de la page */
    html, body, [class*="css"]  {
        font-family: 'Poppins', sans-serif;
        background-color: #f7f9fb;
        color: #222;
    }
    /* Titres du niveau 1 √† 5 */
    h1, h2, h3, h4, h5 {
        color: #2E4057;
        font-weight: 600;
    }
    /* Styles des m√©triques (valeurs et √©tiquettes) */
    [data-testid="stMetricValue"] { /* Valeurs */
        font-size: 1.6rem;
        color: #2E4057;
    }
    [data-testid="stMetricLabel"] { /* √âtiquettes */
        color: #6c757d;
    }
    div[data-testid="stHorizontalBlock"] { /* Conteneurs de m√©triques en ligne */
        background-color: white;
        border-radius: 15px;
        padding: 25px;
        box-shadow: 0 6px 14px rgba(0,0,0,0.06);
    }
    section[data-testid="stSidebar"] { /* Barre lat√©rale */
        background-color: #f0f2f6;
        border-right: 2px solid #e0e0e0;
    }
    section[data-testid="stSidebar"] h2 { /* Titres de la barre lat√©rale */
        color: #2E4057;
    }
    /* Styles des tableaux */
    table {
        border-collapse: collapse;
        width: 100%;
        border-radius: 12px;
        overflow: hidden;
    }
    table th {
        background-color: #2E4057;
        color: white;
        padding: 10px;
    }
    table td {
        padding: 8px;
        background-color: #ffffff;
    }
    table tr:nth-child(even) td {
        background-color: #f8f9fa;
    }
    table tr:hover td {
        background-color: #e9ecef;
    }
    /* Styles des images dans les tableaux */
    table img {
        border-radius: 8px;
        margin-right: 4px;
        box-shadow: 0 3px 6px rgba(0,0,0,0.1);
    }
    /* Styles des graphiques Plotly */
    .plotly-graph-div {
        background-color: white !important;
        border-radius: 12px;
        box-shadow: 0 6px 14px rgba(0,0,0,0.06);
        padding: 15px;
    }
    /* Styles des onglets */
    [role="tab"] {
        background-color: #e9ecef;
        color: #2E4057;
        border-radius: 8px 8px 0 0;
        padding: 8px 16px;
        margin-right: 4px;
        font-weight: 600;
    }
    [role="tab"][aria-selected="true"] {
        background-color: #3b82f6;
        color: white;
    }
    [role="tabpanel"] {
        background-color: white;
        border-radius: 0 0 12px 12px;
        padding: 20px;
        box-shadow: 0 6px 14px rgba(0,0,0,0.06);
    }
    /* Styles des boutons */
    button {
        background-color: #3b82f6;
        color: white;
        border: none;
        border-radius: 8px;
        padding: 10px 20px;
        font-weight: 600;
    }
    button:hover {
        background-color: #2563eb;
        cursor: pointer;
    }
    </style>
    """, unsafe_allow_html=True)


@st.cache_data
def load_data() -> pd.DataFrame:
    """
    Charge les donn√©es depuis le fichier CSV h√©berg√© sur GitHub.

    Retourne:
    - DataFrame contenant les donn√©es des annonces.
    """
    headers = {"Authorization": f"token {GITHUB_TOKEN}"}
    response = requests.get(CSV_URL, headers=headers)
    if response.status_code == 200:
        return pd.read_csv(StringIO(response.text))
    st.error(f"‚ùå Impossible de charger le fichier CSV ({response.status_code})")
    return pd.DataFrame()


def render_header():
    """Affiche le titre principal et la description du tableau de bord."""
    st.markdown(
        "<h1 style='text-align:center'>üè° Tableau de Bord ‚Äî "
        "<span style='color:#3b82f6'>Analyse du March√© Immobilier</span></h1>",
        unsafe_allow_html=True
    )
    st.markdown(
        "<p style='text-align:center; color:#6c757d'>Projet LDF ‚Äî Cr√©ation d'un Pipeline de Donn√©es</p>",
        unsafe_allow_html=True
    )
    st.divider()


def render_summary(df: pd.DataFrame):
    """
    Affiche les m√©triques principales.
    
    Param√®tres:
    - df : DataFrame contenant les donn√©es des annonces.
    """
    col1, col2, col3, col4 = st.columns(4)
    col1.metric("**üìä Nombre d'annonces**", len(df))
    if "prix_m2" in df:
        col2.metric("**üí∂ Prix moyen/m¬≤**", f"{df['prix_m2'].mean():,.0f} ‚Ç¨")
    if "surface" in df:
        col3.metric("**üìê Surface moyenne**", f"{df['surface'].mean():.0f} m¬≤")
    if "ville" in df:
        col4.metric("**üèôÔ∏è Nombre de villes**", df['ville'].nunique())
    st.divider()


def sidebar_filters(df: pd.DataFrame):
    """
    Cr√©e et applique les filtres de la barre lat√©rale avec un vrai reset visuel.
    """
    st.sidebar.header("üéØ Filtres")
    st.sidebar.markdown("Affinez votre recherche ci-dessous üëá")

    # --- Initialisation globale ---
    if "filters_reset_count" not in st.session_state:
        st.session_state.filters_reset_count = 0  # üëà sert √† forcer la recr√©ation des widgets

    # --- Bouton de reset ---
    if st.sidebar.button("üîÑ R√©initialiser les filtres"):
        st.session_state.filters_reset_count += 1
        st.rerun()  # recharge la page avec de nouvelles cl√©s

    # --- Cl√©s dynamiques pour forcer le reset visuel ---
    key_suffix = f"_{st.session_state.filters_reset_count}"

    # === Widgets ===
    ville = st.sidebar.multiselect(
        "üèôÔ∏è Ville",
        sorted(df["ville"].dropna().unique()),
        default=[],
        key=f"ville_filter{key_suffix}"
    )
    type_bien = st.sidebar.multiselect(
        "üè† Type de bien",
        sorted(df["type"].dropna().unique()),
        default=[],
        key=f"type_filter{key_suffix}"
    )
    prix_min, prix_max = st.sidebar.slider(
        "üí∞ Prix (‚Ç¨)",
        int(df["prix"].min()),
        int(df["prix"].max()),
        (int(df["prix"].min()), int(df["prix"].max())),
        key=f"prix_range{key_suffix}"
    )
    surface_min, surface_max = st.sidebar.slider(
        "üìè Surface (m¬≤)",
        int(df["surface"].min()),
        int(df["surface"].max()),
        (int(df["surface"].min()), int(df["surface"].max())),
        key=f"surface_range{key_suffix}"
    )

    # === Application des filtres ===
    filtered_df = df.copy()
    if ville:
        filtered_df = filtered_df[filtered_df["ville"].isin(ville)]
    if type_bien:
        filtered_df = filtered_df[filtered_df["type"].isin(type_bien)]
    filtered_df = filtered_df[
        (filtered_df["prix"] >= prix_min)
        & (filtered_df["prix"] <= prix_max)
        & (filtered_df["surface"] >= surface_min)
        & (filtered_df["surface"] <= surface_max)
    ]

    return filtered_df


def render_data_table(df: pd.DataFrame):
    """
    Affiche la table pagin√©e des annonces avec :
    - Boutons Pr√©c√©dent / Suivant
    - Num√©ro de page pour sauter directement
    - Boutons rapides pour avancer ou reculer de 5 pages
    """
    st.subheader("üìã Annonces filtr√©es")

    page_size = 10
    total_rows = len(df)
    total_pages = (total_rows - 1) // page_size + 1

    # --- ü©µ R√©initialisation automatique si le nombre de lignes a chang√© ---
    if "last_total_rows" not in st.session_state:
        st.session_state.last_total_rows = total_rows

    if "current_page" not in st.session_state:
        st.session_state.current_page = 1

    # Si le dataset filtr√© a chang√© ‚Üí revenir √† la page 1
    if total_rows != st.session_state.last_total_rows:
        st.session_state.current_page = 1
        st.session_state.last_total_rows = total_rows

    # --- Navigation ---
    col_prev5, col_prev1, col_page, col_next1, col_next5 = st.columns([1, 1, 2, 1, 1])

    if col_prev5.button("‚èÆÔ∏è -5"):
        st.session_state.current_page = max(1, st.session_state.current_page - 5)
    if col_prev1.button("‚¨ÖÔ∏è"):
        st.session_state.current_page = max(1, st.session_state.current_page - 1)
    # Ajoute la page actuelle au milieu + le nombre total de pages (affichage s√©curis√©, page/<total_pages>)
    if col_page.button(f"Page {st.session_state.current_page} / {total_pages}"):
        pass  # Ne fait rien, juste pour l'affichage
    if col_next1.button("‚û°Ô∏è"):
        st.session_state.current_page = min(total_pages, st.session_state.current_page + 1)
    if col_next5.button("‚è≠Ô∏è +5"):
        st.session_state.current_page = min(total_pages, st.session_state.current_page + 5)

    # --- Champ pour aller √† une page sp√©cifique ---
    st.session_state.current_page = st.number_input(
        "Aller √† la page :", 
        min_value=1,
        max_value=total_pages,
        value=min(st.session_state.current_page, total_pages),  # üëà s√©curit√© suppl√©mentaire
        step=1
    )

    # Affichage de la page actuelle
    st.markdown(
        f"<p style='text-align:center; font-weight:600'>Page {st.session_state.current_page} / {total_pages}</p>",
        unsafe_allow_html=True
    )

    # D√©coupage des donn√©es
    start = (st.session_state.current_page - 1) * page_size
    end = st.session_state.current_page * page_size
    page_df = df.iloc[start:end].copy()

    colonnes_affichees = ["type", "ville", "prix", "surface", "prix_m2", "images_page", "lien"]
    page_df = page_df[[c for c in colonnes_affichees if c in page_df.columns]]

    # === Formats ===
    if "prix" in page_df:
        page_df["prix"] = page_df["prix"].apply(lambda x: f"{x:,.0f} ‚Ç¨")
    if "surface" in page_df:
        page_df["surface"] = page_df["surface"].apply(lambda x: f"{x:,.0f} m¬≤")
    if "prix_m2" in page_df:
        page_df["prix_m2"] = page_df["prix_m2"].apply(lambda x: f"{x:,.0f} ‚Ç¨/m¬≤")

    # === Liens ===
    if "lien" in page_df:
        page_df["lien"] = page_df["lien"].apply(lambda x: f'<a href="{x}" target="_blank">üîó Voir</a>')

    # === Galerie ===
    if "images_page" in page_df:
        def render_gallery(images):
            try:
                imgs = eval(images) if isinstance(images, str) else images
                if isinstance(imgs, list) and imgs:
                    return " ".join([f'<img src="{img}" width="60">' for img in imgs[:5]])
                return "‚Äî"
            except Exception:
                return "‚Äî"
        page_df["galerie"] = page_df["images_page"].apply(render_gallery)
        page_df.drop(columns=["images_page"], inplace=True)

    page_df.columns = ['Type', 'Ville', 'Prix', 'Surface', 'Prix/m¬≤', 'Lien', 'Galerie']

    st.write(page_df.to_html(escape=False, index=False), unsafe_allow_html=True)
    st.caption(f"üìÑ Total : {total_rows} annonces")



def render_visualizations(df: pd.DataFrame):
    """
    Affiche les graphiques d'analyse.

    Param√®tres:
    - df : DataFrame contenant les donn√©es des annonces.
    """
    st.subheader("üìä Visualisations")
    colA, colB = st.columns(2)

    with colA:
        if "prix" in df:
            fig = px.histogram(df, x="prix", nbins=30, color_discrete_sequence=["#3b82f6"])
            fig.update_layout(title="Distribution des prix (‚Ç¨)", title_x=0.3, xaxis_title="Prix (‚Ç¨)", yaxis_title="Nombre d'annonces")
            st.plotly_chart(fig, use_container_width=True)

    with colB:
        if "prix_m2" in df:
            fig = px.box(df, y="prix_m2", color_discrete_sequence=["#10b981"])
            fig.update_layout(title="Boxplot du prix au m¬≤", title_x=0.3, yaxis_title="Prix/m¬≤ (‚Ç¨)")
            st.plotly_chart(fig, use_container_width=True)

    if "ville" in df:
        st.subheader("üèôÔ∏è R√©partition par ville")

        # On pr√©pare les donn√©es
        data_villes = df["ville"].value_counts().reset_index()
        data_villes.columns = ["Ville", "Nombre d'annonces"]

        # On laisse Plotly g√©rer la couleur par Ville
        fig = px.bar(
            data_villes,
            x="Ville",
            y="Nombre d'annonces",
            color="Ville",  # üëà cl√© : une couleur par ville
            title="Nombre d'annonces par ville",
        )

        # Options visuelles
        fig.update_layout(
            title_x=0.3,
            showlegend=False,  # tu peux mettre True si tu veux afficher la l√©gende
        )

        st.plotly_chart(fig, use_container_width=True)


def render_rankings(df: pd.DataFrame):
    """
    Affiche les classements des villes selon le prix moyen/m¬≤ et la surface moyenne.
    Montre le top 10 et le bottom 10 pour chaque crit√®re.
    """
    st.subheader("üèÖ Classements des villes")

    # --- Classement par prix au m¬≤ ---
    if "ville" in df and "prix_m2" in df:
        classement_prix = (
            df.groupby("ville")["prix_m2"]
            .mean()
            .reset_index()
            .sort_values(by="prix_m2", ascending=True)
        )
        classement_prix.columns = ["Ville", "Prix moyen/m¬≤ (‚Ç¨)"]

        # Top 10 moins ch√®res
        top_10_moins_cheres = classement_prix.head(10).reset_index(drop=True)
        top_10_moins_cheres.index += 1  # Pour afficher la position

        # Top 10 plus ch√®res
        top_10_plus_cheres = classement_prix.tail(10).sort_values(by="Prix moyen/m¬≤ (‚Ç¨)", ascending=False).reset_index(drop=True)
        top_10_plus_cheres.index += 1

        st.markdown("### üí∂ Classement par prix moyen/m¬≤")
        col1, col2 = st.columns(2)
        with col1:
            st.markdown("**üîπ 10 villes les moins ch√®res (‚Ç¨/m¬≤)**")
            st.write(top_10_moins_cheres.style.format({"Prix moyen/m¬≤ (‚Ç¨)": "{:,.0f} ‚Ç¨"}).to_html(escape=False), unsafe_allow_html=True)
        with col2:
            st.markdown("**üî∏ 10 villes les plus ch√®res (‚Ç¨/m¬≤)**")
            st.write(top_10_plus_cheres.style.format({"Prix moyen/m¬≤ (‚Ç¨)": "{:,.0f} ‚Ç¨"}).to_html(escape=False), unsafe_allow_html=True)

    # --- Classement par surface moyenne ---
    if "ville" in df and "surface" in df:
        classement_surface = (
            df.groupby("ville")["surface"]
            .mean()
            .reset_index()
            .sort_values(by="surface", ascending=False)
        )
        classement_surface.columns = ["Ville", "Surface moyenne (m¬≤)"]

        # Top 10 plus grandes
        top_10_plus_grandes = classement_surface.head(10).reset_index(drop=True)
        top_10_plus_grandes.index += 1

        # Top 10 plus petites
        top_10_plus_petites = classement_surface.tail(10).sort_values(by="Surface moyenne (m¬≤)", ascending=True).reset_index(drop=True)
        top_10_plus_petites.index += 1

        st.markdown("### üìè Classement par surface moyenne")
        col1, col2 = st.columns(2)
        with col1:
            st.markdown("**üîπ 10 villes avec la plus grande surface moyenne**")
            st.write(top_10_plus_grandes.style.format({"Surface moyenne (m¬≤)": "{:,.0f} m¬≤"}).to_html(escape=False), unsafe_allow_html=True)

        with col2:
            st.markdown("**üî∏ 10 villes avec la plus petite surface moyenne**")
            st.write(top_10_plus_petites.style.format({"Surface moyenne (m¬≤)": "{:,.0f} m¬≤"}).to_html(escape=False), unsafe_allow_html=True)


def render_settings():
    """Affiche les param√®tres de l'application."""
    st.subheader("‚öôÔ∏è Param√®tres")
    st.markdown("Aucun param√®tre disponible pour le moment.")


# =========================
# Application principale
# =========================
def main():
    apply_custom_css()

    df = load_data()
    if df.empty:
        st.stop()

    render_header()
    filtered_df = sidebar_filters(df)

    render_summary(filtered_df)

    tab1, tab2, tab3, tab4 = st.tabs(["üìã Donn√©es", "üìä Visualisations", "üèÖ Classements", "‚öôÔ∏è Param√®tres"])
    with tab1:
        render_data_table(filtered_df)
    with tab2:
        render_visualizations(filtered_df)
    with tab3:
        render_rankings(filtered_df)
    with tab4:
        render_settings()


if __name__ == "__main__":
    main()
